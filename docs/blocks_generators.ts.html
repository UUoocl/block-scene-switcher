<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: blocks/generators.ts</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: blocks/generators.ts</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file generators.ts
 * @description Defines the JavaScript code generation logic for custom Blockly blocks.
 * 
 * COMMENTARY: Generators are responsible for translating visual blocks into executable
 * JavaScript strings. Each generator function handles a specific block type,
 * extracting field values and input connections to build the resulting code.
 * The use of `javascriptGenerator.statementToCode` allows for recursive code 
 * generation of nested block structures.
 */

import { javascriptGenerator } from 'blockly/javascript';
import * as Blockly from 'blockly';

/**
 * Initializes all custom OBS and API block generators.
 */
export const initObsGenerators = () => {
  // Events
  javascriptGenerator.forBlock['obs_event_scene_changed'] = (block: Blockly.Block) => {
    const branch = javascriptGenerator.statementToCode(block, 'DO');
    return `window.obsWss.on('CurrentProgramSceneChanged', async (data) => {\n${branch}\n});\n`;
  };

  javascriptGenerator.forBlock['obs_event_mute_changed'] = (block: Blockly.Block) => {
    const branch = javascriptGenerator.statementToCode(block, 'DO');
    return `window.obsWss.on('InputMuteStateChanged', async (data) => {\n${branch}\n});\n`;
  };

  javascriptGenerator.forBlock['obs_event_stream_state'] = (block: Blockly.Block) => {
    const branch = javascriptGenerator.statementToCode(block, 'DO');
    return `window.obsWss.on('StreamStateChanged', async (data) => {\n${branch}\n});\n`;
  };

  javascriptGenerator.forBlock['obs_event_input_settings_changed'] = (block: Blockly.Block) => {
    const branch = javascriptGenerator.statementToCode(block, 'DO');
    return `window.obsWss.on('InputSettingsChanged', async (data) => {\n${branch}\n});\n`;
  };

  javascriptGenerator.forBlock['obs_event_custom'] = (block: Blockly.Block) => {
    const branch = javascriptGenerator.statementToCode(block, 'DO');
    return `window.obsWss.on('CustomEvent', async (data) => {\n${branch}\n});\n`;
  };

  javascriptGenerator.forBlock['obs_event_input_active_state_changed'] = (block: Blockly.Block) => {
    const branch = javascriptGenerator.statementToCode(block, 'DO');
    return `window.obsWss.on('InputActiveStateChanged', async (data) => {\n${branch}\n});\n`;
  };

  javascriptGenerator.forBlock['obs_event_input_show_state_changed'] = (block: Blockly.Block) => {
    const branch = javascriptGenerator.statementToCode(block, 'DO');
    return `window.obsWss.on('InputShowStateChanged', async (data) => {\n${branch}\n});\n`;
  };

  javascriptGenerator.forBlock['obs_event_scene_item_enable_state_changed'] = (block: Blockly.Block) => {
    const branch = javascriptGenerator.statementToCode(block, 'DO');
    return `window.obsWss.on('SceneItemEnableStateChanged', async (data) => {\n${branch}\n});\n`;
  };

  javascriptGenerator.forBlock['obs_event_scene_item_lock_state_changed'] = (block: Blockly.Block) => {
    const branch = javascriptGenerator.statementToCode(block, 'DO');
    return `window.obsWss.on('SceneItemLockStateChanged', async (data) => {\n${branch}\n});\n`;
  };

  // Requests
  javascriptGenerator.forBlock['obs_request_set_scene'] = (block: Blockly.Block) => {
    const scene = block.getFieldValue('SCENE');
    return `await window.obsWss.call('SetCurrentProgramScene', { sceneName: '${scene}' });\n`;
  };

  javascriptGenerator.forBlock['obs_request_set_mute'] = (block: Blockly.Block) => {
    const input = block.getFieldValue('INPUT');
    const muted = block.getFieldValue('MUTE') === 'TRUE';
    return `await window.obsWss.call('SetInputMute', { inputName: '${input}', inputMuted: ${muted} });\n`;
  };

  javascriptGenerator.forBlock['obs_request_control_stream'] = (block: Blockly.Block) => {
    const action = block.getFieldValue('ACTION');
    return `await window.obsWss.call('${action}');\n`;
  };

  // NEW GENERATOR
  javascriptGenerator.forBlock['obs_request_set_input_settings'] = (block: Blockly.Block) => {
    const inputName = block.getFieldValue('INPUT');
    const overlay = block.getFieldValue('OVERLAY') === 'TRUE';
    // Ensure we have a default empty JSON object if input is missing
    const settings = javascriptGenerator.valueToCode(block, 'SETTINGS', javascriptGenerator.ORDER_ATOMIC) || '"{}"';
    
    // We assume the input provided by the user is a JSON String, so we parse it.
    return `await window.obsWss.call('SetInputSettings', { inputName: '${inputName}', inputSettings: JSON.parse(${settings}), overlay: ${overlay} });\n`;
  };
  // NEW GENERATOR: Console Log
  javascriptGenerator.forBlock['custom_console_log'] = (block: Blockly.Block) => {
    const logData = javascriptGenerator.valueToCode(block, 'LOG_DATA', javascriptGenerator.ORDER_ATOMIC) || "''";
    return `console.log(${logData});\n`;
  };

  // --- BROADCAST CHANNEL API ---
  javascriptGenerator.forBlock['broadcast_send'] = (block: Blockly.Block) => {
    const channel = block.getFieldValue('CHANNEL');
    const message = javascriptGenerator.valueToCode(block, 'MESSAGE', javascriptGenerator.ORDER_ATOMIC) || "''";
    return `(new BroadcastChannel('${channel}')).postMessage(${message});\n`;
  };

  javascriptGenerator.forBlock['broadcast_receive'] = (block: Blockly.Block) => {
    const channel = block.getFieldValue('CHANNEL');
    const branch = javascriptGenerator.statementToCode(block, 'DO');
    return `
(function() {
  const bc = new BroadcastChannel('${channel}');
  bc.onmessage = (event) => {
    const broadcast_received_message = event.data;
    ${branch}
  };
})();
`;
  };

  javascriptGenerator.forBlock['broadcast_message_object'] = (block: Blockly.Block) => {
    return ['broadcast_received_message', javascriptGenerator.ORDER_ATOMIC];
  };

  // --- SERVER SENT EVENTS (SSE) ---
  javascriptGenerator.forBlock['sse_listen'] = (block: Blockly.Block) => {
    const url = block.getFieldValue('URL');
    const eventName = block.getFieldValue('EVENT');
    const branch = javascriptGenerator.statementToCode(block, 'DO');
    
    let eventSetup = '';
    if (eventName) {
      eventSetup = `
  es.addEventListener('${eventName}', (event) => {
    const sse_message = event.data;
    ${branch}
  });`;
    } else {
      eventSetup = `
  es.onmessage = (event) => {
    const sse_message = event.data;
    ${branch}
  };`;
    }

    return `
(function() {
  const es = new EventSource('${url}');
${eventSetup}
})();
`;
  };

  javascriptGenerator.forBlock['sse_message_object'] = (block: Blockly.Block) => {
    return ['sse_message', javascriptGenerator.ORDER_ATOMIC];
  };

};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#connectOBS">connectOBS</a></li><li><a href="global.html#defineObsBlocks">defineObsBlocks</a></li><li><a href="global.html#ensureGlobalObsWss">ensureGlobalObsWss</a></li><li><a href="global.html#fetchApiDetails">fetchApiDetails</a></li><li><a href="global.html#fetchLocalList">fetchLocalList</a></li><li><a href="global.html#fetchObsidianList">fetchObsidianList</a></li><li><a href="global.html#forceStopDeployment">forceStopDeployment</a></li><li><a href="global.html#getCssVariableDetails">getCssVariableDetails</a></li><li><a href="global.html#getLocalStorageDetails">getLocalStorageDetails</a></li><li><a href="global.html#getUrlParamDetails">getUrlParamDetails</a></li><li><a href="global.html#initDeployHandlers">initDeployHandlers</a></li><li><a href="global.html#initFileHandlers">initFileHandlers</a></li><li><a href="global.html#initLoadModal">initLoadModal</a></li><li><a href="global.html#initObsGenerators">initObsGenerators</a></li><li><a href="global.html#initSaveModal">initSaveModal</a></li><li><a href="global.html#loadAndInject">loadAndInject</a></li><li><a href="global.html#loadFromLocal">loadFromLocal</a></li><li><a href="global.html#loadFromObsidian">loadFromObsidian</a></li><li><a href="global.html#manageObsConnection">manageObsConnection</a></li><li><a href="global.html#refreshFileList">refreshFileList</a></li><li><a href="global.html#saveToLocal">saveToLocal</a></li><li><a href="global.html#saveToObsidian">saveToObsidian</a></li><li><a href="global.html#sceneOptions">sceneOptions</a></li><li><a href="global.html#setSceneOptions">setSceneOptions</a></li><li><a href="global.html#setupEventListeners">setupEventListeners</a></li><li><a href="global.html#showConnectionModal">showConnectionModal</a></li><li><a href="global.html#stopDeployment">stopDeployment</a></li><li><a href="global.html#triggerDeployment">triggerDeployment</a></li><li><a href="global.html#updateButtonStyle">updateButtonStyle</a></li><li><a href="global.html#workspace">workspace</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Mon Jan 05 2026 13:10:21 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
